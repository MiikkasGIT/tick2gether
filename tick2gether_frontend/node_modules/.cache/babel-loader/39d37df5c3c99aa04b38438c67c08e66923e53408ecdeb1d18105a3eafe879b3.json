{"ast":null,"code":"import { Stomp } from '@stomp/stompjs';\nimport SockJS from 'sockjs-client';\n\n// WebSocket URL - Ersetze dies durch die tatsächliche URL deines WebSocket-Servers\nconst SOCKET_URL = 'http://localhost:8080/ws';\nclass WebSocketService {\n  constructor() {\n    this.stompClient = null;\n    this.connected = false;\n    this.reconnectDelay = 5000; // 5 Sekunden\n    this.subscriptions = {}; // Abonnements speichern, um doppelte Listener zu vermeiden\n    this.connect = this.connect.bind(this);\n  }\n\n  // Methode zum Verbinden mit dem WebSocket-Server\n  async connect(onTaskMessageReceived, onCategoryMessageReceived, userId) {\n    if (this.stompClient) {\n      console.log('Bereits mit WebSocket verbunden');\n      return; // Verhindert eine erneute Verbindung, wenn bereits verbunden\n    }\n    console.log('Versuche, WebSocket zu verbinden...');\n    const socket = new SockJS(SOCKET_URL);\n    this.stompClient = Stomp.over(socket);\n    try {\n      await new Promise((resolve, reject) => {\n        this.stompClient.connect({}, frame => {\n          console.log('Mit WebSocket verbunden:', frame);\n          this.connected = true;\n          this.subscribeToTopics(userId, onTaskMessageReceived, onCategoryMessageReceived);\n          resolve();\n        }, error => {\n          console.error('Fehler beim Verbinden mit WebSocket:', error);\n          this.connected = false;\n          reject(error);\n        });\n      });\n    } catch (error) {\n      console.log(`Wiederverbindungsversuch in ${this.reconnectDelay / 1000} Sekunden...`);\n      setTimeout(() => this.connect(onTaskMessageReceived, onCategoryMessageReceived, userId), this.reconnectDelay);\n    }\n  }\n\n  // Methode zum Abonnieren von Themen\n  subscribeToTopics(userId, onTaskMessageReceived, onCategoryMessageReceived) {\n    if (!this.subscriptions[`tasks-${userId}`]) {\n      console.log(`Abonnieren von Aufgaben für Benutzer ${userId}`);\n      this.subscriptions[`tasks-${userId}`] = this.stompClient.subscribe(`/user/${userId}/topic/tasks`, message => {\n        console.log('Aufgaben-Nachricht erhalten:', message.body);\n        try {\n          const taskMessage = JSON.parse(message.body);\n          console.log('Geparste Aufgaben-Nachricht:', taskMessage);\n          onTaskMessageReceived(taskMessage);\n        } catch (error) {\n          console.error('Fehler beim Parsen der Aufgaben-Nachricht:', error);\n        }\n      });\n    }\n    if (!this.subscriptions[`categories-${userId}`]) {\n      console.log(`Abonnieren von Kategorien für Benutzer ${userId}`);\n      this.subscriptions[`categories-${userId}`] = this.stompClient.subscribe(`/user/${userId}/topic/categories`, message => {\n        console.log('Kategorisierung-Nachricht erhalten:', message.body);\n        try {\n          const categoryMessage = JSON.parse(message.body);\n          console.log('Geparste Kategorisierung-Nachricht:', categoryMessage);\n          onCategoryMessageReceived(categoryMessage);\n        } catch (error) {\n          console.error('Fehler beim Parsen der Kategorisierung-Nachricht:', error);\n        }\n      });\n    }\n  }\n\n  // Methode zum Trennen der WebSocket-Verbindung\n  disconnect() {\n    if (this.stompClient) {\n      this.stompClient.disconnect(() => {\n        console.log('Von WebSocket getrennt');\n        this.connected = false;\n      });\n    } else {\n      console.warn('WebSocket-Client ist nicht vorhanden. Keine Verbindung zum Trennen.');\n    }\n  }\n\n  // Methode zum Senden von Nachrichten über WebSocket\n  sendMessage(destination, message) {\n    if (this.stompClient && this.stompClient.connected) {\n      try {\n        this.stompClient.send(destination, {}, JSON.stringify(message));\n        console.log('WebSocket-Nachricht gesendet:', {\n          destination,\n          message\n        });\n      } catch (error) {\n        console.error('Fehler beim Senden der WebSocket-Nachricht:', error);\n      }\n    } else {\n      console.error('Nachricht konnte nicht gesendet werden. WebSocket-Verbindung ist nicht hergestellt.');\n    }\n  }\n\n  // Überprüft, ob der WebSocket verbunden ist\n  isConnected() {\n    return this.connected;\n  }\n}\n\n// Instanziierung der WebSocketService-Klasse\nconst webSocketService = new WebSocketService();\nexport const connectWebSocket = (onTaskMessageReceived, onCategoryMessageReceived, userId) => {\n  webSocketService.connect(onTaskMessageReceived, onCategoryMessageReceived, userId);\n};\nexport const disconnectWebSocket = () => {\n  console.log('Trenne WebSocket-Verbindung...');\n  webSocketService.disconnect();\n};\nexport const sendWebSocketMessage = (destination, message) => {\n  console.log('Sende WebSocket-Nachricht...');\n  webSocketService.sendMessage(destination, message);\n};","map":{"version":3,"names":["Stomp","SockJS","SOCKET_URL","WebSocketService","constructor","stompClient","connected","reconnectDelay","subscriptions","connect","bind","onTaskMessageReceived","onCategoryMessageReceived","userId","console","log","socket","over","Promise","resolve","reject","frame","subscribeToTopics","error","setTimeout","subscribe","message","body","taskMessage","JSON","parse","categoryMessage","disconnect","warn","sendMessage","destination","send","stringify","isConnected","webSocketService","connectWebSocket","disconnectWebSocket","sendWebSocketMessage"],"sources":["/Users/finngarrels/IdeaProjects/Tick2GetherProject/tick2gether_frontend/src/websocket.js"],"sourcesContent":["import { Stomp } from '@stomp/stompjs';\nimport SockJS from 'sockjs-client';\n\n// WebSocket URL - Ersetze dies durch die tatsächliche URL deines WebSocket-Servers\nconst SOCKET_URL = 'http://localhost:8080/ws';\n\nclass WebSocketService {\n  constructor() {\n    this.stompClient = null;\n    this.connected = false;\n    this.reconnectDelay = 5000; // 5 Sekunden\n    this.subscriptions = {}; // Abonnements speichern, um doppelte Listener zu vermeiden\n    this.connect = this.connect.bind(this);\n  }\n\n  // Methode zum Verbinden mit dem WebSocket-Server\n  async connect(onTaskMessageReceived, onCategoryMessageReceived, userId) {\n    if (this.stompClient) {\n      console.log('Bereits mit WebSocket verbunden');\n      return; // Verhindert eine erneute Verbindung, wenn bereits verbunden\n    }\n\n    console.log('Versuche, WebSocket zu verbinden...');\n    const socket = new SockJS(SOCKET_URL);\n    this.stompClient = Stomp.over(socket);\n\n    try {\n      await new Promise((resolve, reject) => {\n        this.stompClient.connect({}, (frame) => {\n          console.log('Mit WebSocket verbunden:', frame);\n          this.connected = true;\n          this.subscribeToTopics(userId, onTaskMessageReceived, onCategoryMessageReceived);\n          resolve();\n        }, (error) => {\n          console.error('Fehler beim Verbinden mit WebSocket:', error);\n          this.connected = false;\n          reject(error);\n        });\n      });\n    } catch (error) {\n      console.log(`Wiederverbindungsversuch in ${this.reconnectDelay / 1000} Sekunden...`);\n      setTimeout(() => this.connect(onTaskMessageReceived, onCategoryMessageReceived, userId), this.reconnectDelay);\n    }\n  }\n\n  // Methode zum Abonnieren von Themen\n  subscribeToTopics(userId, onTaskMessageReceived, onCategoryMessageReceived) {\n    if (!this.subscriptions[`tasks-${userId}`]) {\n      console.log(`Abonnieren von Aufgaben für Benutzer ${userId}`);\n      this.subscriptions[`tasks-${userId}`] = this.stompClient.subscribe(`/user/${userId}/topic/tasks`, (message) => {\n        console.log('Aufgaben-Nachricht erhalten:', message.body);\n        try {\n          const taskMessage = JSON.parse(message.body);\n          console.log('Geparste Aufgaben-Nachricht:', taskMessage);\n          onTaskMessageReceived(taskMessage);\n        } catch (error) {\n          console.error('Fehler beim Parsen der Aufgaben-Nachricht:', error);\n        }\n      });\n    }\n\n    if (!this.subscriptions[`categories-${userId}`]) {\n      console.log(`Abonnieren von Kategorien für Benutzer ${userId}`);\n      this.subscriptions[`categories-${userId}`] = this.stompClient.subscribe(`/user/${userId}/topic/categories`, (message) => {\n        console.log('Kategorisierung-Nachricht erhalten:', message.body);\n        try {\n          const categoryMessage = JSON.parse(message.body);\n          console.log('Geparste Kategorisierung-Nachricht:', categoryMessage);\n          onCategoryMessageReceived(categoryMessage);\n        } catch (error) {\n          console.error('Fehler beim Parsen der Kategorisierung-Nachricht:', error);\n        }\n      });\n    }\n  }\n\n  // Methode zum Trennen der WebSocket-Verbindung\n  disconnect() {\n    if (this.stompClient) {\n      this.stompClient.disconnect(() => {\n        console.log('Von WebSocket getrennt');\n        this.connected = false;\n      });\n    } else {\n      console.warn('WebSocket-Client ist nicht vorhanden. Keine Verbindung zum Trennen.');\n    }\n  }\n\n  // Methode zum Senden von Nachrichten über WebSocket\n  sendMessage(destination, message) {\n    if (this.stompClient && this.stompClient.connected) {\n      try {\n        this.stompClient.send(destination, {}, JSON.stringify(message));\n        console.log('WebSocket-Nachricht gesendet:', { destination, message });\n      } catch (error) {\n        console.error('Fehler beim Senden der WebSocket-Nachricht:', error);\n      }\n    } else {\n      console.error('Nachricht konnte nicht gesendet werden. WebSocket-Verbindung ist nicht hergestellt.');\n    }\n  }\n\n  // Überprüft, ob der WebSocket verbunden ist\n  isConnected() {\n    return this.connected;\n  }\n}\n\n// Instanziierung der WebSocketService-Klasse\nconst webSocketService = new WebSocketService();\n\nexport const connectWebSocket = (onTaskMessageReceived, onCategoryMessageReceived, userId) => {\n  webSocketService.connect(onTaskMessageReceived, onCategoryMessageReceived, userId);\n};\n\nexport const disconnectWebSocket = () => {\n  console.log('Trenne WebSocket-Verbindung...');\n  webSocketService.disconnect();\n};\n\nexport const sendWebSocketMessage = (destination, message) => {\n  console.log('Sende WebSocket-Nachricht...');\n  webSocketService.sendMessage(destination, message);\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
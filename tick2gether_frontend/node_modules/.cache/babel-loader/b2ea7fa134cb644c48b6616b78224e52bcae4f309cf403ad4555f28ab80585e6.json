{"ast":null,"code":"var _s = $RefreshSig$();\n// src/hooks/useTasksAndCategories.js\n\nimport { useState, useCallback } from 'react';\nimport { addTask, deleteTask, updateTask, fetchTasks } from '../api';\nimport { sendWebSocketMessage, sendUpdateTaskMessage } from '../websocket';\nexport function useTasksAndCategories(userId, selectedCategory, initialTasks, initialCategories) {\n  _s();\n  const [tasks, setTasks] = useState(initialTasks);\n  const [categories, setCategories] = useState(initialCategories);\n  const handleAddNewTask = useCallback(async newTask => {\n    try {\n      const formattedTask = {\n        ...newTask,\n        categoryId: (selectedCategory === null || selectedCategory === void 0 ? void 0 : selectedCategory.id) || newTask.categoryId,\n        userId\n      };\n      console.log(\"Formatted Task before sending to backend:\", formattedTask);\n      const addedTask = await addTask(formattedTask, userId);\n      setTasks(prevTasks => [...prevTasks, addedTask]);\n      sendUpdateTaskMessage(addedTask);\n    } catch (error) {\n      console.error('Error adding task:', error);\n    }\n  }, [userId, selectedCategory]);\n  const handleSaveTask = useCallback(async updatedTask => {\n    try {\n      const taskToUpdate = {\n        ...updatedTask,\n        userId,\n        taskId: updatedTask.taskId,\n        categoryId: (selectedCategory === null || selectedCategory === void 0 ? void 0 : selectedCategory.id) || updatedTask.categoryId\n      };\n      console.log(\"Task to Update before sending to backend:\", taskToUpdate);\n      setTasks(prevTasks => prevTasks.map(task => task.taskId === taskToUpdate.taskId ? taskToUpdate : task));\n      sendUpdateTaskMessage(taskToUpdate);\n    } catch (error) {\n      console.error('Error editing task:', error);\n    }\n  }, [userId, selectedCategory]);\n  const handleDeleteTask = useCallback(async id => {\n    try {\n      await deleteTask(id);\n      setTasks(prevTasks => prevTasks.filter(task => task.taskId !== id));\n      sendWebSocketMessage(`/app/deleteTask/${id}`, {\n        type: 'TASK_DELETE',\n        taskId: id\n      });\n    } catch (error) {\n      console.error('Error deleting task:', error);\n    }\n  }, []);\n  const handleAddCategory = useCallback(async newCategory => {\n    try {\n      const categoryExists = categories.some(cat => cat.name === newCategory.name);\n      if (categoryExists) {\n        console.warn('Category already exists:', newCategory);\n        return;\n      }\n      const data = await addCategory(newCategory);\n      const newCategoryObject = {\n        id: data.categoryId,\n        name: data.name,\n        icon: customCategoryIcon // Customize this if needed\n      };\n      sendWebSocketMessage(`/app/updateCategory/${newCategoryObject.id}`, {\n        type: 'CATEGORY_UPDATE',\n        category: newCategoryObject\n      });\n      setCategories(prevCategories => [...prevCategories, newCategoryObject]);\n    } catch (error) {\n      console.error('Error adding category:', error);\n    }\n  }, [categories]);\n  return {\n    tasks,\n    categories,\n    handleAddNewTask,\n    handleSaveTask,\n    handleDeleteTask,\n    handleAddCategory,\n    setTasks,\n    setCategories\n  };\n}\n_s(useTasksAndCategories, \"gGv6WgAeViglxtf1FG90NKrPCyc=\");","map":{"version":3,"names":["useState","useCallback","addTask","deleteTask","updateTask","fetchTasks","sendWebSocketMessage","sendUpdateTaskMessage","useTasksAndCategories","userId","selectedCategory","initialTasks","initialCategories","_s","tasks","setTasks","categories","setCategories","handleAddNewTask","newTask","formattedTask","categoryId","id","console","log","addedTask","prevTasks","error","handleSaveTask","updatedTask","taskToUpdate","taskId","map","task","handleDeleteTask","filter","type","handleAddCategory","newCategory","categoryExists","some","cat","name","warn","data","addCategory","newCategoryObject","icon","customCategoryIcon","category","prevCategories"],"sources":["/Users/finngarrels/IdeaProjects/Tick2GetherProject/tick2gether_frontend/src/hooks/useTasksAndCategories.js"],"sourcesContent":["// src/hooks/useTasksAndCategories.js\n\nimport { useState, useCallback } from 'react';\nimport { addTask, deleteTask, updateTask, fetchTasks } from '../api';\nimport { sendWebSocketMessage, sendUpdateTaskMessage } from '../websocket';\n\nexport function useTasksAndCategories(userId, selectedCategory, initialTasks, initialCategories) {\n  const [tasks, setTasks] = useState(initialTasks);\n  const [categories, setCategories] = useState(initialCategories);\n\n  const handleAddNewTask = useCallback(async (newTask) => {\n    try {\n      const formattedTask = {\n        ...newTask,\n        categoryId: selectedCategory?.id || newTask.categoryId,\n        userId\n      };\n      console.log(\"Formatted Task before sending to backend:\", formattedTask);\n      const addedTask = await addTask(formattedTask, userId);\n      setTasks(prevTasks => [...prevTasks, addedTask]);\n      sendUpdateTaskMessage(addedTask);\n    } catch (error) {\n      console.error('Error adding task:', error);\n    }\n  }, [userId, selectedCategory]);\n\n  const handleSaveTask = useCallback(async (updatedTask) => {\n    try {\n      const taskToUpdate = {\n        ...updatedTask,\n        userId,\n        taskId: updatedTask.taskId,\n        categoryId: selectedCategory?.id || updatedTask.categoryId,\n      };\n      console.log(\"Task to Update before sending to backend:\", taskToUpdate);\n      setTasks(prevTasks => prevTasks.map(task => (task.taskId === taskToUpdate.taskId ? taskToUpdate : task)));\n      sendUpdateTaskMessage(taskToUpdate);\n    } catch (error) {\n      console.error('Error editing task:', error);\n    }\n  }, [userId, selectedCategory]);\n\n  const handleDeleteTask = useCallback(async (id) => {\n    try {\n      await deleteTask(id);\n      setTasks(prevTasks => prevTasks.filter(task => task.taskId !== id));\n      sendWebSocketMessage(`/app/deleteTask/${id}`, { type: 'TASK_DELETE', taskId: id });\n    } catch (error) {\n      console.error('Error deleting task:', error);\n    }\n  }, []);\n\n  const handleAddCategory = useCallback(async (newCategory) => {\n    try {\n      const categoryExists = categories.some(cat => cat.name === newCategory.name);\n      if (categoryExists) {\n        console.warn('Category already exists:', newCategory);\n        return;\n      }\n      const data = await addCategory(newCategory);\n      const newCategoryObject = {\n        id: data.categoryId,\n        name: data.name,\n        icon: customCategoryIcon, // Customize this if needed\n      };\n      sendWebSocketMessage(`/app/updateCategory/${newCategoryObject.id}`, { type: 'CATEGORY_UPDATE', category: newCategoryObject });\n      setCategories(prevCategories => [...prevCategories, newCategoryObject]);\n    } catch (error) {\n      console.error('Error adding category:', error);\n    }\n  }, [categories]);\n\n  return {\n    tasks,\n    categories,\n    handleAddNewTask,\n    handleSaveTask,\n    handleDeleteTask,\n    handleAddCategory,\n    setTasks,\n    setCategories\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}